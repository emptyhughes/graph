<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1">
	<script src="./co.js"></script>
	<script> 
		let counter = 0;	
		let run = true;
		function stopAnimation() {run = false} 
		function startAnimation() {run = true} 
	</script>
</head>
<body>
<input type='button' value='start' onclick = 'startAnimation()'></input><span id='counter'></span><input type='button' value='stop' onclick = 'stopAnimation()'></input><span id='counter'></span>
<div id='tree'></div>
</body>
<script type='module' >
	import { require } from "./npnrequire.js";
	//import * as d3 from "https://d3js.org/d3.v6.js";
	let d3 = require("https://d3js.org/d3.v6.js")
	
	let dot = require("https://cdn.jsdelivr.net/npm/@observablehq/graphviz@0.2.1/dist/graphviz.min.js")
	
	function computeNodes() {
	  const map = new Map;
	  
	  function get(name) {
		let node = map.get(name);
		if (!node) map.set(name, node = new Node(name));
		return node;
	  }
	  
	  for (const [i, o] of edges) {
		const nodeIn = get(i);
		const nodeOut = get(o);
		nodeIn.outputs.add(nodeOut);
		nodeOut.inputs.add(nodeIn);
	  }
	  
	  return [...map.values()];
	}
	
	function* computeSequence() {
	  const nodes = computeNodes();
	  const queue = [];
	  for (const node of nodes) {
		if (!(node.indegree = node.inputs.size)) {
		  queue.push(node);
		}
	  }
	  let node;
	  yield {nodes, first: true};
	  while (node = queue.pop()) {
		node.computed = true;
		for (const output of node.outputs) {
		  if (!--output.indegree) {
			queue.push(output);
		  }
		}
		yield {node, nodes};
	  }
	  yield {nodes};
	}
	
	class Node {
	  constructor(name) {
		this.name = name;
		this.computed = false;
		this.indegree = 0;
		this.inputs = new Set;
		this.outputs = new Set;
	  }
	}

	let edges = [
	  ["d3", "chart"],
	  ["DOM", "chart"],
	  ["width", "chart"],
	  ["height", "chart"],
	  ["data", "chart"],
	  ["x", "chart"],
	  ["y", "chart"],
	  ["xAxis", "chart"],
	  ["yAxis", "chart"],
	  ["require", "data"],
	  ["d3", "x"],
	  ["data", "x"],
	  ["margin", "x"],
	  ["width", "x"],
	  ["d3", "y"],
	  ["data", "y"],
	  ["height", "y"],
	  ["margin", "y"],
	  ["d3", "xAxis"],
	  ["height", "xAxis"],
	  ["margin", "xAxis"],
	  ["x", "xAxis"],
	  ["d3", "yAxis"],
	  ["margin", "yAxis"],
	  ["y", "yAxis"],
	  ["require", "d3"]
	]	
	
	let d2 = dot`digraph "d3-bar-chart" {
	${edges.map(([i, o]) => `${i} -> ${o}`).join("\n")}
	}`;
	
	//document.body.appendChild(d2);
	
	//from observable stllib
	let delay = function(duration, value) {
	  return new Promise(function(resolve) {
		setTimeout(function() {
		  resolve(value);
		}, duration);
	  });
	}
			
	/*let graph = co(function*() {
		//"use strict";
	  //graph_replay;
	  let firstDelay = 0;
	  while (true) {
		for (const {first, node, nodes} of computeSequence()) {
		  yield delay(first ? firstDelay : 1000, 
		  dot`digraph "d3-bar-chart" {
			  ${nodes.map(n => 
				`${n.name} [label="${n.name} (${n.indegree})" color=${node === n ? "red" : n.computed ? "black" : n.indegree ? "white" : "gray"}]`).join("\n")}
				${nodes.map(i => [...i.outputs].map(o => `${i.name} -> ${o.name} [color=${node === i ? "red" : i.computed ? "black" : "gray"}]`).join("\n")).join("\n")}
			}`);
		}
		firstDelay = 30000;
	  }
	});
	
	graph.then(function (val) {
		document.body.appendChild(val);	
	});*/
	
	let graph = function*() { 
		"use strict";
		let d = null;
		
		let firstDelay = 0;
		
		let count = 0;
		while (run) {
			counter++;
			for (const {first, node, nodes} of computeSequence()) {		
					d = dot`digraph "d3-bar-chart" {
						  ${nodes.map(n => 
							`${n.name} [label="${n.name} (${n.indegree})" color=${node === n ? "red" : n.computed ? "black" : n.indegree ? "white" : "gray"}]`).join("\n")}
							${nodes.map(i => [...i.outputs].map(o => `${i.name} -> ${o.name} [color=${node === i ? "red" : i.computed ? "black" : "gray"}]`).join("\n")).join("\n")}
						}`			
				yield d;
			}
			firstDelay = 30000;
		}
		return d;
	}
	
	let tree = document.querySelector('#tree');
	let oldchild = document.createElement('svg');
	tree.appendChild(oldchild);
	
	let ecounter = document.querySelector('#counter');	

	const sequence = graph();
	
	updateGraph();
	
	function updateGraph() {
		let s = sequence.next();
		tree.replaceChild(s.value, oldchild);
		oldchild = s.value;
		let wait = true;
		//await delay(500,1).then(()=>{});
		count();
	}	
	
	function count() {
		counter++;
		ecounter.innerHTML = counter;
		if(counter <= 1000)
			delay(250,1).then( () => {updateGraph();} )
		else 
		return 0;
	}	
		
</script>


</html>